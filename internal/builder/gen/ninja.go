package gen

import (
	"os"
	"os/exec"
	"strings"
)

type NinjaGen struct {
	cc, cxx string
	targets map[string]buildUnit
}

func (g *NinjaGen) SetCompiler(cc, cxx string) {
	g.cc, g.cxx = cc, cxx
}

func (g *NinjaGen) BuildFile() string { return "build.ninja" }

var ninjaPathEscaper = strings.NewReplacer(":", "$:", " ", "$ ")

func quote(s string) string { return ninjaPathEscaper.Replace(s) }

// AddTarget adds a package (library or executable) to the build graph
func (g *NinjaGen) AddTarget(name, basedir string, sources []SourceFile, dependencies []string, isLib bool, cflags, ldflags []string) {
	if g.targets == nil {
		g.targets = make(map[string]buildUnit)
	}

	g.targets[name] = buildUnit{
		name:         name,
		isLib:        isLib,
		sources:      sources,
		dependencies: dependencies,
		cflags:       cflags,
		ldflags:      ldflags,
	}
}

func (g *NinjaGen) Generate() string {
	var sb strings.Builder

	writeln(&sb, "# This file is @generated by Qobs: DO NOT EDIT!")
	writeln(&sb, "ninja_required_version = 1.1")
	//writeln(&sb, "cflags = ", g.cflags)
	//writeln(&sb, "ldflags = ", g.ldflags)
	writeln(&sb, "cc = ", g.cc)
	writeln(&sb, "cxx = ", g.cxx)
	writeln(&sb)

	// gen rules
	write(&sb,
		`rule cc
  command = $cc $cflags -c $in -o $out
  description = CC $out
`)
	write(&sb,
		`rule cxx
  command = $cxx $cflags -c $in -o $out
  description = CXX $out
`)
	write(&sb,
		`rule link
  command = $cc -o $out $in $ldflags
  description = LINK $out
`)
	write(&sb,
		`rule linkxx
  command = $cxx -o $out $in $ldflags
  description = LINK $out
`)
	write(&sb,
		`rule ar
  command = ar rcs $out $in
  description = AR $out
`)
	writeln(&sb)

	// build object files
	var useCxxLinker bool
	for _, target := range g.targets {
		for _, source := range target.sources {
			if source.IsCxx {
				writeln(&sb, "build ", source.Obj, ": cxx ", quote(source.Src))
				useCxxLinker = true
			} else {
				writeln(&sb, "build ", source.Obj, ": cc ", quote(source.Src))
			}
			writeln(&sb, "  cflags = ", strings.Join(target.cflags, " "))
		}
	}

	// ar/link
	for _, target := range g.targets {
		write(&sb, "build ", target.name, ": ")
		if target.isLib {
			write(&sb, "ar")
		} else if useCxxLinker {
			write(&sb, "linkxx")
		} else {
			write(&sb, "link")
		}

		// add the object files and dependencies of this package
		for _, source := range target.sources {
			write(&sb, " ", source.Obj)
		}
		for _, dep := range target.dependencies {
			write(&sb, " ", dep)
		}
		writeln(&sb)
		writeln(&sb, "  ldflags = ", strings.Join(target.ldflags, " "))
	}

	return sb.String()
}

func (g *NinjaGen) Invoke(buildDir string) error {
	cmd := exec.Command("ninja", "-C", buildDir)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	return cmd.Run()
}
